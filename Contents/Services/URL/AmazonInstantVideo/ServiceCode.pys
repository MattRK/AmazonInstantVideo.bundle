#   Copyright 2013 Josh Kearney
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import datetime
import time

import constants as c


def MetadataObjectForURL(url):
    asin = url.split("=", 1)[1]
    url = c.AMAZON_URL + "/dp/" + asin
    page = HTML.ElementFromURL(url)

    title = page.xpath(c.TITLE_PATTERN)[0].strip()
    summary = page.xpath(c.SUMMARY_PATTERN)[0].strip()
    image_link = page.xpath(c.IMAGE_LINK_PATTERN)[0]
    thumb = Resource.ContentsOfURLWithFallback(url=image_link, fallback=c.PLUGIN_ICON_DEFAULT)

    video_metadata = parse_video_metadata(page)
    episode_metadata = parse_episode_metadata(page, title)
    movie_metadata = parse_movie_metadata(page)

    kwargs = {
        "title": title,
        "summary": summary,
        "thumb": thumb
    }

    if video_metadata and episode_metadata:
        kwargs.update(video_metadata)
        kwargs.update(episode_metadata)

        return EpisodeObject(**kwargs)
    elif video_metadata and movie_metadata:
        kwargs.update(video_metadata)
        kwargs.update(movie_metadata)

        return MovieObject(**kwargs)

    return MovieObject(**kwargs)


def MediaObjectsForURL(url):
    return [
        MediaObject(
            protocol="rtmp",
            parts=[
                PartObject(
                    key=Callback(PlayVideo, url=url),
                    streams=[
                        AudioStreamObject(language_code=Locale.Language.English)
                    ]
                )
            ]
        )
    ]


@indirect
def PlayVideo(url):
    flash_vars = parse_flash_vars(url)
    rtmp_url, clip, swf_url = prepare_rtmp_info(flash_vars)

    return IndirectResponse(VideoClipObject, key=RTMPVideoURL(url=rtmp_url, clip=clip, swf_url=swf_url))


def parse_video_metadata(page):
    try:
        rating = float(page.xpath(c.RATING_PATTERN)[0].split(" out of ", 1)[0]) * 2
        pretty_duration = page.xpath(c.DURATION_PATTERN)[0].strip().split(" ", 3)
        content_rating = page.xpath(c.CONTENT_RATING_PATTERN)[0].split("Rated ", 1)[0]

        if len(pretty_duration) < 3:
            duration = 60000 * int(pretty_duration[0])
        else:
            duration = 3600000 * int(pretty_duration[0]) + 60000 * int(pretty_duration[2])
    except (IndexError, ValueError):
        return None

    return {
        "rating": rating,
        "content_rating": content_rating,
        "duration": duration
    }


def parse_episode_metadata(page, title):
    try:
        show_info = title.split(" Season ", 1)
        show_name = show_info[0]

        episode_info = show_info[1].split(", ", 1)

        season = int(episode_info[0])
        episode_number, episode_name = episode_info[1].split("Ep. ", 1)[1].split(" ", 1)
        episode_number = int(episode_number)

        air_date = pretty_duration = page.xpath(c.AIRDATE_PATTERN)[0].strip().split(" ", 3)
        air_date = datetime.datetime.strptime(" ".join(air_date), '%B %d, %Y')
    except (IndexError, ValueError):
        return None

    return {
        "title": episode_name[1:-1],
        "show": show_name,
        "originally_available_at": air_date,
        "season": season,
        "index": episode_number
    }


def parse_movie_metadata(page):
    try:
        release_year = int(page.xpath(c.RELEASE_YEAR_PATTERN)[0])
        studio = page.xpath(c.STUDIO_PATTERN)[0].strip()

        directors = []
        for director in page.xpath(c.DIRECTOR_PATTERN)[0].split(","):
            directors.append(director.strip())
    except (IndexError, ValueError):
        return None

    return {
        "year": release_year,
        "studio": studio,
        "directors": directors
    }


def parse_flash_vars(url):
    page_content = HTTP.Request(url, follow_redirects=False, immediate=True).content

    flash = Regex("'flashVars', '(.*?)' \+ new Date\(\)\.getTime\(\)\+ '(.*?)'", Regex.DOTALL).findall(page_content)
    flash = (flash[0][0] + flash[0][1]).split("&")

    flash_vars = {
        "firmware": "WIN%2010,0,181,14%20PlugIn",
        "url": url,
        "swf_url": Regex("avodSwfUrl = '(.*?)'\;").findall(page_content)[0]
    }

    for var in flash:
        var = var.split("=")
        if var[0] == "token":
            flash_vars[var[0]] = var[1]
        elif var[0] == "customer":
            flash_vars["customerID"] = var[1]
        elif var[0] == "ASIN":
            flash_vars["asin"] = var[1]

    flash_vars["deviceID"] = flash_vars["customerID"] + str(int(time.time() * 1000)) + flash_vars["asin"]

    return flash_vars


def prepare_rtmp_info(flash_vars):
    stream_url = "https://atv-ps.amazon.com/cdp/catalog/GetStreamingUrlSets?deviceTypeID=A13Q6A55DBZB7M&version=1&asin=%(asin)s&firmware=%(firmware)s&customerID=%(customerID)s&token=%(token)s&format=json&deviceID=%(deviceID)s" % flash_vars

    cookies = HTTP.CookiesForURL(flash_vars["url"])

    stream_data = JSON.ObjectFromURL(stream_url, headers={"Cookie": cookies})
    stream_json = stream_data["message"]["body"]["urlSets"]["streamingURLInfoSet"][0]["streamingURLInfo"]

    streams = []
    for stream in stream_json:
        if stream["drm"] == "NONE":
            streams.append((int(stream["bitrate"]), stream["url"]))

    # NOTE(jk0): Use the highest bitrate available.
    streams.sort(key=lambda x: x[0], reverse=True)

    rtmp_url = streams[0][1]
    protocol = rtmp_url.split("://")
    path = protocol[1].split("/")
    hostname = path[0]
    app_name = protocol[1].split(hostname + "/")[1].split("/")[0]
    stream_auth = rtmp_url.split(app_name + "/")[1].split("?")
    stream = stream_auth[0].replace(".mp4", "")
    auth = stream_auth[1]
    identurl = "http://" + hostname + "/fcs/ident"
    ident = HTTP.Request(identurl).content
    ip = Regex("<fcs><ip>(.+?)</ip></fcs>").findall(ident)[0]
    base_rtmp = "rtmpe://" + ip + ":1935/" + app_name + "?_fcs_vhost=" + hostname + "&ovpfv=2.1.4&" + auth

    final_url = base_rtmp
    final_url += " playpath=" + stream
    final_url += " pageurl=" + flash_vars["url"]
    final_url += " swfurl=" + flash_vars["swf_url"] + " swfvfy=true"

    return final_url, stream, flash_vars["swf_url"]
